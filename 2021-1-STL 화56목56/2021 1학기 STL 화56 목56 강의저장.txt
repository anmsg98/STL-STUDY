===============================================
저장시간 : 2021-03-04 오후 1:15:40 목요일
===============================================
//-------------------------------------------------------------
// X86 mode & Release mode 에서 프로그램
//
// 2021. 1학기 STL 화56 목56  - 3월 2일 화요일		(1주 1차시)
//
// 실행 될 때마다 소스파일을 저장한다.
//-------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	/*save("save.cpp");
	save("save.h");*/
	
	return 0;
}

--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

using namespace std;

// [문제] main()을 변경하지 않고 실행 되도록 하자.
// Game은 사용자가 정의하는 클래스이다.
// 화면 출력은 2,1로
class Game {
public:
	Game(int n) :n{ n } {};
private:
	int n;
	friend ostream& operator<<(ostream& os, const Game& game);
};
void change(Game& a, Game& b);

int main()
{
	Game a{ 1 };
	Game b{ 2 };
	
	change(a, b);

	cout << a << ", " << b << endl;
	
	return 0;
}
ostream& operator<<(ostream& os, const Game& game)
{
	os << game.n;
	return os;
}

void change(Game& a, Game& b) {
	Game temp{ a };
	a = b;
	b = temp;
}
--------------------------------------------------------------------------------------------------------------------
// [문제] main()을 변경하지 않고 실행 되도록 하자.
// 앞에서 만든 change()가 다른 자료형도 바꿀수 있도록 하자.
// 화면 출력은 2,1로
template <typename T>
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
};

int main()
{
	int a{ 1 };
	int b{ 2 };
	
	change(a, b);

	cout << a << ", " << b << endl;
	
	return 0;
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;
 
// [문제] int 20개를 저장할 공간을 마련한다
// int를 임의의 값(랜덤엔진과 분포)으로 만든다.
// 값을 오름 or 내림차순으로 정렬 해보자.
// 화면에 int 값을 출력하자.

default_random_engine dre; // 랜덤 엔진

int main()
{
	uniform_int_distribution uid{ 1,1000 }; // 범위 지정 가능

	int arr[20];
	for (int& n : arr)
		n = uid(dre);

	for (int n : arr)
		cout << n << " ";
	cout << endl << "정렬" << endl;
	// 정렬한다
	sort(begin(arr), end(arr), greater<int>()); // 3번째 인자로 정렬방법을 결정할 수 있음.
	// sort 함수는 원소의개수 X log(원소의개수)의 시간 복잡도를 가짐 qsort임.
	//또는 [](int a, int b) {return a < b; } (람다([]) 함수를 쓰는게 효율이 제일 좋음)
	
	for (int n : arr)
		cout << n << " ";
	cout << endl;
	
	return 0;
}
===============================================
저장시간 : 2021-03-09 오후 2:01:38 화요일
===============================================
//--------------------------------------------------------------------
// X86 mode & Release mode 에서 프로그램
//
// 2021. 1학기 STL 화56 목56  - 3월 9일 화요일	(2주 1차시)
//
// 많은 수의 데이터 다루기 - int 에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다
//
// sort 설명 다시 - 함수의 역할 / 비교 횟수 등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기


// [문제] int 1,000,000 개를 저장할 공간을 마련하라
// 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출력하라.

default_random_engine dre; // 랜덤 엔진
int arr[1000000]; // 지역 변수 스택 할당값은 1mb - 따라서 전역변수에
int main()
{
	uniform_int_distribution uid; // 범위 지정 가능
	for (int& n : arr)
		n = uid(dre);

	sort(begin(arr), end(arr));
	cout << "처음 원소의 값 - " << *begin(arr) << endl;
	cout << "마지막 원소의 값 - " << *(end(arr) - 1) << endl;
	cout << endl;

	
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <string_view>
#include "save.h"
using namespace std;
 
// [문제] 파일 "오름차순 정렬한 int 100개.txt"가 있다.
// 읽어서 화면에 출력


int main()
{
	string_view sv = "오름차순정렬한 int 100개.txt"sv;
	ifstream in(sv.data());
	if (!in) {
		cout << sv << "파일을 열수 없습니다." << endl;
		exit(0);
	}
	int arr[100];
	for (int& n:arr)
		in >> n;

	for (int n : arr)
		cout << n << " ";
	cout << endl;
	
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <numeric>
#include "save.h"
using namespace std;
 
// [문제] 정수 100개를 400바이트 공간에 기록하자.
// int a[100]개 값을 1부터 100으로 채우고
// 파일 "int 100개.txt"에 저장
// 파일 크기는 무조건 400byte
int main()
{
	int arr[100];
	iota(begin(arr), end(arr), 1);
	ofstream out("int 100개.txt");
	
	out.write((char*)arr, 100 * sizeof(int));

	
}

===============================================
저장시간 : 2021-03-11 오후 1:45:59 목요일
===============================================
//--------------------------------------------------------------------
// X86 mode & Release mode 에서 프로그램
//
// 2021. 1학기 STL 화56 목56  - 3월 11일 목요일	(2주 2차시)
//
// 많은 수의 데이터 다루기 - int 에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다
//
// sort 설명 다시 - 함수의 역할 / 비교 횟수 등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//--------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;
 
// [문제] 파일 "int 100개.txt"에 바이너리로 저장되어있는 정수 100개가 있다.
// 읽은 정수 100개를 내림차순으로 정렬한 후 출력.

int main()
{
	int arr[100];
	ifstream in("int 100개.txt", ios::binary);

	if (!in)
		exit(0);

	in.read((char*)&arr, 100 * sizeof(int));
	sort(begin(arr), end(arr), [](int a, int b) {return a > b; });

	for (int n : arr)
		cout << n << " ";
	
	cout << endl;
	
	

}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"
using namespace std;
 
// [문제] 사용자가 원하는 갯수 num만큼 int를 저장할 공간을 확보한다
// 이 공간을 1부터 num까지 숫자로 채워라.
// 처음과 마지막 값을 화면에 출력.
int main()
{
	cout << "몇개의 int를 원하십니까: ";
	int num;
	cin >> num;
	int* arr;
		try {
		arr = new int[num]; // 배열 버전 new 연산자를 사용한다. *배열 길이는 상수가 아니여도 된다*. 
	}
	catch (exception& e) {
		cout << e.what() << endl;
	} // 예외가 발생했을경우 프로그램 강제종료가 아닌 오류 메세지 출력 
	for (int i = 0; i < num; i++)
		arr[i] = i + 1;
	cout << "처음 원소의 값: " << arr[0] << endl;
	cout << "마지막 원소의 값: " << arr[num - 1] << endl;

	delete[] arr;
	
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// core c++ guide - raw pointer를 사용하지 말 것.

int main()
{
	int cnt{};
	while (true) {
		// 확보한 자원은 지역을 벗어나며 자동으로 메모리 해제(delete)
		unique_ptr<char[]> p{ new char[500000000] };

		cout << ++cnt << "\r";
		break;

	}
	
}

===============================================
저장시간 : 2021-03-11 오후 3:18:16 목요일
===============================================
//--------------------------------------------------------------------
// 2021. 1학기 STL 화56 목56  - 3월 11일 목요일	(2주 2차시)
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//--------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include "save.h"
using namespace std;

int main()
{
	//(수까락의 프로그래밍 참고)
	auto b = chrono::steady_clock::now();	//스톱워치 시작
	this_thread::sleep_for(100ms);
	auto e = chrono::steady_clock::now();	// 스톱워치 끝
	auto d = e - b;
	cout << "경과시간(밀리초) - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;
	
}

===============================================
저장시간 : 2021-03-16 오후 1:50:38 화요일
===============================================
//-----------------------------------------------------------------
// 2021. 1학기 STL 화56 목56  - 3월 16일 화요일            (3주 1일)
//
// Dog 만들고 저장하고 읽어 정렬하기 시작할 것
// callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//-----------------------------------------------------------------

#include <iostream>
#include <random>
#include <string>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// sizeof(Dog)를 확인하자

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);
		
		++cnt;
	}

private:
	int id;			// 4
	string name;	// 24 (28 - debug) -x64

	static int cnt; // 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

int main()
{
	Dog dogs[10];

	for (const Dog& dog : dogs)
		cout << dog << endl;

	
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <string>
#include <fstream>
#include <memory>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] Dog 객체를 만들어 파일에 저장하고 다시 읽어 정렬해 본다.
// 파일 "Dog 만객체"에 바이너리 모드로 저장되어 있는 Dog 10000 객체를 읽어라 
// id 오름차순으로 정렬

default_random_engine dre;
uniform_int_distribution<> uid;

class Dog {
public:
	Dog() : id{ uid(dre) } {
		name = "Dog"s;
		name += to_string(cnt);
		
		++cnt;
	}
	int getID() const {
		return id;
	}

private:
	int id;			// 4
	string name;	// 24 (28 - debug) -x64

	static int cnt; // 4 - 클래스 공통

	friend ostream& operator<<(ostream& os, const Dog& dog);
};

int Dog::cnt = { 1 };

ostream& operator<<(ostream& os, const Dog& dog)
{
	os << "이름: " << dog.name << ", 아이디: " << dog.id;
	return os;
}

Dog dogs[10000];

int main()
{

	ifstream in{ "Dog 만객체.txt",ios::binary };
	
	unique_ptr<Dog[]> dogs{ new Dog[10000] }; // 같은 타입의 포인터로 받아야됨

	in.read((char*)dogs.get(), sizeof(Dog) * 10000);
	
	sort(&dogs[0], &dogs[10000], [](const Dog& a, const Dog& b)	{return a.getID() < b.getID(); });
	
	for (int i = 0; i < 10000; i++)
		cout << dogs[i] << endl;
	
	
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std;

void f(int)
{
	cout << "나는 그냥 함수야" << endl;
}

class Test {
public:
	void operator()(int) {
		cout << "나는 클래스가 구현한 연산자() 야" << endl;
	}
	void(*m)(int) = f;
};

auto x = [](int) -> void {
	cout << "람다" << endl;
};


int main()
{
	// f를 다른 변수에 저장할 수 있을까?
	void(*a)(int) = f;

	cout << typeid(a).name() << endl;

	
}

=============================================
저장시간 : 2021-03-18 오후 1:53:09 목요일
=============================================
//------------------------------------------------------------------
// 2021 1학기 STL 화56 목56     - 3월 18일 목요일 (3주 2일)
// 
// 호출 가능한 타입 - callable type
//
// 앞으로 사용할 관찰용 class 만들어 두기
//------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"
#define _CRT_SECURE_NO_WARNINGS
using namespace std;

void jump(void)
{
    cout <<"점프합니다." << endl;
}
void slide(void)
{
    cout << "슬라이드합니다." << endl;
}

int main()
{
    void (*f)(void); // 호출 가능 타입
    f = jump;
    f();
    cout << "main의 번지수는 " << main << endl;
    cout << "f의 번지수는 " << f << endl;
    cout << "변수 f의 번지수는 " << &f << endl;
    int a;
    cout << "스택에 있는 a의 번지수는 " << &a << endl;

    f = slide;
    f();
    cout << "f의 번지수는 " << f << endl;
    save("STL.cpp");

}
------------------------------------------------------------------------
#include <iostream>
#include <functional>
#include "save.h"
#define _CRT_SECURE_NO_WARNINGS
using namespace std;

// 1. 일반함수
void f(int) 
{
    cout << "일반함수를 호출했다" << endl;
}

// 2. 함수객체
class Test {
public:
    void operator()(int) {
        cout << "()연산자를 오버로딩한 클래스를 호출했다 " << endl;
    }

    void mf(int) {
        cout << "멤버펑션 호출 " << endl;
    }
};

// 3. 람다
auto lambda = [](int) {
    cout << "람다를 호출했다" << endl;
};

//[문제] : callable type에 각 함수를 저장했다 호출해보자

int main()
{
    function<void(int)> ct; //통일된 타입 서로다른함수를 가리킬 수 있다.

    ct = f;
    ct(1);

    Test t;
    ct = t;
    ct(2);

    ct = [](int) {
        cout << "람다를 호출했다" << endl;
    };
    ct(3);

    
    save("STL.cpp");
}

===============================================
저장시간 : 2021-03-23 오후 2:06:01 화요일
===============================================
//-----------------------------------------------------------------
// 2021. 1학기 STL 화56 목56  - 3월 23일 화요일            (4주 1일)
//
// 앞으로 사용할 관찰용 class(자원을 확보하는) 만들어 두기
//-----------------------------------------------------------------

#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;

// [문제] int num을 인자로 받아 메모리를 num바이트 할당받아
// 임의의 알파벳  소문자로 채우는 클래스 String을 코딩

mt19937 dre;
uniform_int_distribution<> uid{ 'a','z' };


class String {
public:
	String(int num) : num{ num }, p{ new char[num] }{
		for (int i = 0; i < num; ++i)
			p[i] = uid(dre);
	}
	
	~String(){
		delete[] p;
	}

	String(const String& other) :num{ other.num }, p{ new char[num] } {
		//cout << "복사";		// switch로 출력 조절
		memcpy(p, other.p, num);
	}

	String& operator=(const String& other) {
		//cout << "할당" << endl;
		if (this != &other) {
			delete[] p;
			num = other.num;
			p = new char[num];
			memcpy(p, other.p, num);
		}

		return *this;
	}

	size_t size() const {
		return num;
	}

	void sortAscending() {
		sort(p, p + num);
	};

private:
	int num{};
	char* p{ nullptr };

	friend ostream& operator<<(ostream&, const String&);
};

ostream& operator << (ostream& os, const String& s) {
	for (int i = 0; i < s.num; ++i) {
		os << s.p[i];
	}
	return os;
}

int main()
{
	String s[10]{ 20,21,3,18,7,8,3,12,33,55 };

	sort(begin(s), end(s), [](const String& a, const String& b) {
		return a.size() < b.size();
		});
	
	// [문제]각 String을 알파벳 오름차순으로 정렬하라
	for (String& s : s)
		s.sortAscending();
	
	for (String& s : s)
		cout << s << endl;

	
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <string>
#include <iterator>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"에 있는 단어를 저장한 후
// 오름차순으로 정렬하여 출력하라.

int main()
{
	ifstream in{ "소스.cpp" };
	vector<string> v{ istream_iterator<string>{in},{} };
	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	
}

===============================================
저장시간 : 2021-03-25 오후 2:06:10 목요일
===============================================
// 2021. 1학기 STL 화56 목56  - 3월 25일 목요일            (4주 2일)
//
// Containers are objects that sotre other objects.
//
// Containers are objects that sotre other objects.
//	- 컨테이너는 다른 객체를 저장하는 객체이다.
//
// Sequence Containers
//	- array
//	- vector
//	- deque
//	- forward_list
//	- list
//-----------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"

using namespace std;

int main()
{
	vector<vector<int>>v{ {1,2,3,}, {4,5,6,7,8}, {100,200,300} };
	for (auto i = v.begin(); i != v.end(); ++i) {
		auto t = *i;
		for (auto ti = t.begin(); ti != t.end(); ++ti)
			cout << *ti << "  ";
		cout << endl;
	}
	
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

// [실습] main이 실행될 수 있게 Array을 프로그램 하라.
template <typename T, int N>
class Array {
	T data[N]{ 0 };
public:
	Array() {
	}
	size_t size() const {
		return N;
	}
	T operator[](int idx) const{
		return data[idx];
	}

	T& operator[](int idx) {
		return data[idx];
	}
	
	T* begin() {
		return data;
	}

	T* end() {
		return data + N;
	}
};

int main()
{
	Array<String, 10> a;
	
	for (int i = 0; i < a.size(); ++i)
		a[i] = i;
	
	for (int i = 0; i < a.size(); ++i)
		cout << a[i] << endl;

	cout << "======반복자로 출력======" << endl;
	for (auto i = a.begin(); i != a.end(); ++i)
		cout << *i << endl;
	
	
}

===============================================
저장시간 : 2021-03-30 오후 1:54:40 화요일
===============================================
//-----------------------------------------------------------------
// 2021. 1학기 STL 화56 목56  - 3월 30일 화요일            (5주 1일)
//
// String.h를 다운받아 공통된 관찰을 해 본다.
//-----------------------------------------------------------------
#include <iostream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] String이 const char*를 인자로 받도록 하자.

int main()
{	
	String s{ "스트링을 만들어 본다" };

	cout << s << endl;

	
}

// [답]
String(const char* str) : num{ strlen(str) }, p{ new char[num] } {
		memcpy(p, str, num);
#ifdef 관찰
		cout << "생성자(const char*) (this:" << this << ") - 갯수: "
			<< num << ", 위치:" << (void*)p << endl;
#endif
	}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] STL 표준 컨테이너에 String을 원소(element)로 넣어본다.
// 사전 순서(lexicographical) 상 오름차순으로 정렬해보자
int main()
{	
	//컨테이너를 동적으로 만들면 X(new)
	array<String, 3> words{ "다음주", "과제를", "준비하겠어요" };
	
	sort(words.begin(), words.end(), [](const String& a, const String& b) {
		return a.getString() < b.getString(); }); // .size를 쓰면 길이 순으로, .getString이면 알파벳 순

	for (const String& word : words)
		cout << word << endl;
	
}
// [답] 
// 확보한 자원을 std::string처럼 이용할 수 있게 하자.
	std::string getString() const {
		return std::string(p, p + num);
	}
--------------------------------------------------------------------------------------------------------------------
// [질문] 배열[]과 array중 무엇을 사용하는 것이 좋은가?
// 메모리상의 장단점 없음 (= 속도차이가 없다)
// 그러나 array는 수많은 method를 가지고있기 때문에 더 유리함.
// vector란? - 동적(컴파일시에는 크기를 알 수 없는) 배열이다.

===============================================
저장시간 : 2021-04-01 오후 2:38:20 목요일
===============================================
//-----------------------------------------------------------------
// 2021. 1학기 STL 화56 목56  - 4월 1일 목요일            (5주 2일)
//
// - vector
//-----------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] vector는 4바이트인 멤버변수가 3개가 있다.
// 한개는 - 동적할당한 주소를 저장하고 있다.
// 한개는 - 원소개수를 저장하고 있다.
// 한개는 - 아직 모른다.
//
// 동적할당한 주소값을 가져와서 그 주소의 내용을 v.size()만큼
// 출력한다면 모든 원소의 값이 화면 출력될 것이다.

int main()
{	
    vector<int> v{ 1, 2, 3, 10, 200, 4000, 7777777 };

    int* p = &v[0];

    for (auto i = 0; i < v.size(); ++i)
    {
        cout << *(p + i) << " ";
    }

	
	//vector의 메모리 재할당에 대해 공부해보자.
}
--------------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] "소스.cpp"를 읽어 vector에 저장한 후 
// 거꾸로 화면에 출력하라.
int main()
{	
	ifstream in{ "소스.cpp" };
	
	vector<char> v;

	char c;
	while (in >> c) {
		v.push_back(c);
	}
	for (auto i = v.rbegin(); i != v.rend(); ++i) {
		cout << *i;
	}

	cout << endl << endl;
	
}

===============================================
저장시간 : 2021-04-06 오후 2:03:24 화요일
===============================================
//-----------------------------------------------------------------
// 2021. 1학기 STL 화56 목56  - 4월 6일 목요일            (6주 1일)
//
// vector는 어떻게 메모리를 관리 하는가
//-----------------------------------------------------------------
#include <iostream>
#include <vector>
#include <fstream>
#include "save.h"
#include "String.h"
using namespace std;

//[문제] "소스.cpp"를 읽어 vector에 저장한 후 거꾸로 화면에 출력하라
// 소문자를 대문자로 바꾸어 출력하라
int main()
{
	vector<char> v;

	ifstream in("소스.cpp");
	
	char c;
	while (in >> noskipws >> c)
		v.push_back(c);

	// 여기에서 v에있는 글자중 소문자를 대문자로 바꾼다
	for (char& c : v)
	{
		c = toupper(c);
	}

	for (auto i = v.rbegin(); i != v.rend(); ++i)
		cout << *i;

	

}
--------------------------------------------------------------------------------------------------------------------
// vector는 멤버변수 3개가 있다.
// 그중 첫째는 Free Store에 확보한 메모리의 시작번지를 저장하고 있다.
// [문제] 첫번째 변수를 이용하여 실제데이터를 억세스하라 

int main()
{
	vector<int> v{ 1,22,333,4444,55555 };

	int** p = reinterpret_cast<int**>(&v);


	for(int i = 0; i < v.size(); ++i)
	{
		cout << *(*p+i) << endl;
	}
	
	
	
}
--------------------------------------------------------------------------------------------------------------------
// vector는 멤버변수 3개가 있다.
// 그중 첫째는 Free Store에 확보한 메모리의 시작번지를 저장하고 있다.
// [문제] 첫번째 변수를 이용하여 실제데이터를 억세스하라 

int main()
{
	vector<int> v{ 1,22,333,4444,55555 };

	int* p = v.data();
	
	for(int i = 0; i < v.size(); ++i)
	{
		cout << *(p + i) << endl;
	}
	
	
	
}
--------------------------------------------------------------------------------------------------------------------
int main()
{
	vector<String> v;
    v.reserve(3);
	v.emplace_back ("안녕?");
	v.emplace_back("벡터야!");

	cout << endl;
	cout << "-------------추가하기전---------------" << endl;;
	cout << endl;

	v.emplace_back("반갑습니다");

	cout << endl;
	cout << "-------------추가한후-----------------" << endl;;
	cout << endl;


	for (String& s : v)
		cout << s << endl;
		
	
}
--------------------------------------------------------------------------------------------------------------------
// vector가 진짜 자료형을 관리할 수 있도록 하자
// - 사용자 정의 자료형이 자원을 관리하는 클래스라면
// - 이동생성과 이동할당연산자를 반드시 구현해야한다.
// - 자료구조에 원소를 추가할때 emplace를 이용하자....
//-----------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{
	vector<String> v{ 20,10,30 };

	//벡터v를 길이 오름차순으로 정렬하시오
	cout << endl;
	cout << "---------정렬전--------" << endl;
	cout << endl;

	sort(v.begin(), v.end(), [](const String& a, const String& b) {
		return a.size() < b.size(); });

	cout << endl;
	cout <<"---------정렬후--------" << endl;
	cout << endl;

}

===============================================
저장시간 : 2021-04-08 오후 1:43:43 목요일
===============================================
//-----------------------------------------------------------------
// 2021. 1학기 STL 화56 목56  - 4월 8일 목요일            (6주 2일)
//
// vector<int> 중간에 원소를 추가해 본다
//	- 자료구조에 무관한 코딩을 하면 자료구조가 바뀌더라도 코드는 변경할 필요가 없다.
//	- 이런 일이 자주 필요한다면 자료구조를 바꿔야 한다.
// vector<int> 에서 짝수를 삭제한다.
//	- remove가 지우는 건 진짜가 아니다.
//	- 실제로 지우는 건 자료구조가 해야 한다.
//
// 중간시험 - 4월 22일 (목요일)
//-----------------------------------------------------------------
#include <iostream>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{	
	vector<int> v{ 1,2,4,5 };

	// [문제] v에 3을 끼워 넣어본다.
	auto p = v.begin();
	advance(p, 2); // 위치를 뒤로 n만큼 옮겨줌
	v.insert(p, 3); // p위치에 3삽입
	//v.insert(p, 100, 333333); // p위치에 333333 100개 삽입
	//v.insert(p, v.begin(), v.end()); // p위치에 v시작부터 종점까지 데이터를 삽입
	for (auto i = v.cbegin(); i != v.cend(); ++i)
		cout << *i << " ";
	cout << endl;
}

--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{	
	vector<int> v{ 1,2,3,4,5,6,7,8,9,10 };

	// [문제] v에서 홀수를 제거하라
	auto p = remove_if(v.begin(), v.end(), [](int val) {
		return (val & 1);
		});

	v.erase(p, v.end()); // v에서 데이터 5개를 지웠지만 여전히 확보공간은 10칸
	v.shrink_to_fit(); // v의 메모리 확보공간을 데이터수에 맞게 맞춘다. - 5칸으로 바뀜

	cout << "v가 확보한 메모리 크기 - " << v.capacity() << endl;
	for (auto i : v)
		cout << i << " ";
	cout << endl;
	save("소스.cpp");
}

--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <deque>
#include "save.h"
#include "String.h"
using namespace std;

int main()
{	
	deque<String> d;

	d.emplace(d.end(), "back");
	d.emplace(d.begin(), "front");
	
	// 중간에 "middle"을 추가해보자
	d.emplace(++d.begin(), "middle");
	for (const String& s : d)
		cout << s << endl;
}

===============================================
저장시간 : 2021-04-13 오후 1:43:09 화요일
===============================================
//-----------------------------------------------------------------
// 2021. 1학기 STL 화56 목56  - 4월 13일 화요일            (7주 1일)
//
// deque - 벡터와 유사한데 차이점이 무엇인지
//	- 실제 메모리가 연속되어 있지 않다 - 그런 척 할 뿐이다(엑세스가 vector 보다 느림)
//	- vector보다 원소를 더 많이 담을 수 있다.
//
// STL contiguous container
//	- array, vector, deque
//	+ [], string
//
// C++ 20 메모리가 연속된 container를 나타내는 span 템플릿 클래스가 추가
//-----------------------------------------------------------------
#include <iostream>
#include <vector>
#include <deque>
#include "save.h"
#include "String.h"
using namespace std;

class Test {
	char c[1024];

public:
	void show() const {
		cout << this << endl;
	}

};
int main()
{	
	vector<Test> d(10);		// 연속적인 메모리 공간에 저장
	//deque<Test> d(10);	// 객체의 뭉치를 list로 관리
	for (int i = 0; i < d.size(); ++i)
		d[i].show();

	save("소스.cpp");
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <deque>
#include "save.h"
#include "String.h"
using namespace std;

// [실험] 
// vector, deque에 int를 하나씩 push_back하며 몇 개 까지 저장할 수 있나 출력하라.
int main()
{	
	vector<int> v;	// 최대 - 13621657(속도는 vector가 빠름)
	//deque<int> d; // 최대 - 268435452(vector보다 두배정도 더 담을 수 있다.)
	while (true){
		
		try {
			v.push_back(1);
		}
		catch (...) {
			cout << "담을수 있는 최대 개수 - " << v.size() << endl;
			break;
		}
	}
	save("소스.cpp");
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] 글자수가 홀수이면 제거하라
int main()
{	
	vector<String> v{ 1,2,3,4,5,6,7,8,9,10 };

	erase_if(v, [](const String& a) {
		return a.size() & 1; 
		}); // c++ 새로운 함수(굳이 안써도 됨)

	for (auto i : v)
		cout << i << endl;

	save("소스.cpp");
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <span>
#include <vector>
#include "save.h"
#include "String.h"
using namespace std;

// [문제] v를 인자로 받아 내용을 화면출력하는 함수 print를 작성하시오

template<typename T>
void print(span<T> s)
{
	for (int i = 0; i < s.size(); ++i)
		cout << s[i] << " ";
	cout << endl;
}

int main()
{	
	vector<String> v{ 10,20,30 };
	print(span<String> {v});
	save("소스.cpp");
<<<<<<< HEAD
}
===============================================
저장시간 : 2021-04-15 오후 1:36:08 목요일
===============================================
//-----------------------------------------------------------------
// 2021. 1학기 STL 화56 목56  - 4월 15일 화요일            (7주 2일)
//
// 1. sequence 컨테이너
//  원소를 삭제/추가하는 동작이 0(1)
//    - list
//    - forword_list
//
// 중간 시험 4/22일 
//-----------------------------------------------------------------
#include <iostream>
#include <deque>
#include <algorithm>
=======
}===============================================
저장시간 : 2021-04-20 오후 1:57:18 화요일
===============================================
//-----------------------------------------------------------------
// 2021. 1학기 STL 화56 목56  - 4월 20일 화요일            (8주 1일)
//
// 반복자 : 책 31~41, 123~136, Design Pattern 중 iterator pattern
// 반복자는 포인터를 추상화한 것이다.
// 반복자처럼 행동하는 것은 반복자이다.
// 반복자는 컨테이너가 제공하는 인터페이스이다.
//-----------------------------------------------------------------
#include <iostream>
>>>>>>> e65a5bab79118c37b79ff95bdc4497cad2dbcd86
#include "save.h"
#include "String.h"
using namespace std;

int main()
<<<<<<< HEAD
{
    deque<int> d{ 1,5,3,9,7 };
    sort(d.begin(),d.end());

    // 전체를 반복자로 순회하며 출력하자
    for (int n :d){
        cout << n << " ";
    }
    cout << endl;

    save("소스.cpp");
}
--------------------------------------------------------------------------------------------------------------------
//[문제] "소스.cpp" 파일을 리스트를 사용해 읽어라
// 거꾸로 찍어라

int main()
{
    ifstream in("소스.cpp", ios::binary);
    list<char> con(istreambuf_iterator<char>{in}, {});

    reverse(con.begin(), con.end());
    //c.reverse(); // 

    for (auto i = con.crbegin(); i != con.crend(); ++i)
    {
        cout << *i;
    }

    // 전체를 반복자로 순회하며 출력하자
    for (const char s : con){
        cout << s ;
    }
    cout << endl;

    save("소스.cpp");
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <list>
#include <algorithm>
#include <iterator>
#include <initializer_list>
#include <fstream>
=======
{	
	String s{ "1234567890" };

	for (auto i = s.begin(); i != s.end(); ++i)
		cout << *i << ' ';
	cout << endl;
	
	save("소스.cpp");
	save("String.h");
}
// ----------------------------------------------------------------------------
// String.h - STL 내부 동작을 관찰하기 위해 만든 자원을 확보하는 클래스
//
// 2021. 3. 30									Programmed by wulong
//-----------------------------------------------------------------------------
	// 2021. 4. 20
	char* begin() {
		return p;
	}
	// 2021. 4. 20
	char* end() {
		return p + num;
	}
--------------------------------------------------------------------------------------------------------------------
// [문제] 반복자를 인자로 받은 함수는 그것이 무엇인지를 어떻게 알까?

template <typename Iter>
void showIteratorCategory(const Iter&)
{
	cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
}

int main()
{	
	vector<int> v;

	auto p = v.begin();

	showIteratorCategory(p);
	save("소스.cpp");
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <vector>
#include <iterator>
#include <forward_list>
#include <list>
>>>>>>> e65a5bab79118c37b79ff95bdc4497cad2dbcd86
#include "save.h"
#include "String.h"
using namespace std;

<<<<<<< HEAD
//[문제] "소스.cpp" 파일을 리스트를 사용해 읽어라
// 거꾸로 찍어라

int main()
{
    ifstream in("소스.cpp", ios::binary);
    list<char> con(istreambuf_iterator<char>{in}, {});
    copy(con.cbegin(), con.cend(), ostream_iterator<char>{cout});


    save("소스.cpp");
}
--------------------------------------------------------------------------------------------------------------------
//[문제] "소스.cpp"d에 소문자는 몇글자인지 출력하라

int main()
{
    ifstream in("소스.cpp", ios::binary);
    list<char> con(istreambuf_iterator<char>{in}, {});

    cout << "소문자 갯수는 : " << count_if(con.cbegin(), con.cend(), [](char c) {return islower(c); }) << endl;
    

    save("소스.cpp");
}
--------------------------------------------------------------------------------------------------------------------
//[문제] "소스.cpp"에 using이라는 단어가 있나
// 있다면 몇 번째 단어인가?

int main()
{
    ifstream in("소스.cpp", ios::binary);
    list<string> con(istream_iterator<string>{in}, {});

    auto p = find(con.cbegin(), con.cend(), "using"s);

    if (p != con.end()) {
        cout << distance(con.cbegin(), p) + 1 << " 번째 단어 입니다" << endl; ;
    }
    else {
        cout << " 찾는 원소가 없습니다. " << endl;
    }

    save("소스.cpp");
}
--------------------------------------------------------------------------------------------------------------------
void print(const list<int> & cont)
{
	for (int n : cont)
		cout << n << " ";
	cout << endl;
}

int main()
{
	list<int> con1{ 5,7,3,1,9 };
	list<int> con2{ 10,4,8,6,2 };

//[문제] con1 과 con2에 있는 내용을 con3에 merge해라

	list<int> con3;
	con3.merge(con1);
	con3.merge(con2);

	print(con1);
	print(con2);
	print(con3);

   save("소스.cpp");
}
--------------------------------------------------------------------------------------------------------------------
void print(const list<int>&);
int main()
{
	list<int> toDo{ 3,5,1,9,7,7,7,7,7,7,7,7 };

	toDo.sort();
	toDo.unique();
	print(toDo);
	
	save("소스.cpp");
}

void print(const list<int>& cont)
{
	for (int n : cont)
		cout << n << " ";
	cout << endl;
=======
// [문제] 반복자를 인자로 받은 함수는 그것이 무엇인지를 어떻게 알까?

template <typename Iter>
void showIteratorCategory(const Iter&)
{
	cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
}

int main()
{	
	showIteratorCategory(istream_iterator<char>{cin});
	showIteratorCategory(ostream_iterator<char>{cout});
	showIteratorCategory(forward_list<int>::iterator());
	showIteratorCategory(list<int>::iterator());
	showIteratorCategory(vector<int>::iterator());

	save("소스.cpp");
>>>>>>> e65a5bab79118c37b79ff95bdc4497cad2dbcd86
}
===============================================
저장시간 : 2021-03-04 오후 1:15:40 목요일
===============================================
//-------------------------------------------------------------
// X86 mode & Release mode 에서 프로그램
//
// 2021. 1학기 STL 화56 목56  - 3월 2일 화요일		(1주 1차시)
//
// 실행 될 때마다 소스파일을 저장한다.
//-------------------------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	/*save("save.cpp");
	save("save.h");*/
	save("소스.cpp");
	return 0;
}

------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"

using namespace std;

// [문제] main()을 변경하지 않고 실행 되도록 하자.
// Game은 사용자가 정의하는 클래스이다.
// 화면 출력은 2,1로
class Game {
public:
	Game(int n) :n{ n } {};
private:
	int n;
	friend ostream& operator<<(ostream& os, const Game& game);
};
void change(Game& a, Game& b);

int main()
{
	Game a{ 1 };
	Game b{ 2 };
	
	change(a, b);

	cout << a << ", " << b << endl;
	save("소스.cpp");
	return 0;
}
ostream& operator<<(ostream& os, const Game& game)
{
	os << game.n;
	return os;
}

void change(Game& a, Game& b) {
	Game temp{ a };
	a = b;
	b = temp;
}
--------------------------------------------------------------------------------------------------------------------
// [문제] main()을 변경하지 않고 실행 되도록 하자.
// 앞에서 만든 change()가 다른 자료형도 바꿀수 있도록 하자.
// 화면 출력은 2,1로
template <typename T>
void change(T& a, T& b) {
	T temp{ a };
	a = b;
	b = temp;
};

int main()
{
	int a{ 1 };
	int b{ 2 };
	
	change(a, b);

	cout << a << ", " << b << endl;
	save("소스.cpp");
	return 0;
}
--------------------------------------------------------------------------------------------------------------------
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;
 
// [문제] int 20개를 저장할 공간을 마련한다
// int를 임의의 값(랜덤엔진과 분포)으로 만든다.
// 값을 오름 or 내림차순으로 정렬 해보자.
// 화면에 int 값을 출력하자.

default_random_engine dre; // 랜덤 엔진

int main()
{
	uniform_int_distribution uid{ 1,1000 }; // 범위 지정 가능

	int arr[20];
	for (int& n : arr)
		n = uid(dre);

	for (int n : arr)
		cout << n << " ";
	cout << endl << "정렬" << endl;
	// 정렬한다
	sort(begin(arr), end(arr), greater<int>()); // 3번째 인자로 정렬방법을 결정할 수 있음.
	// sort 함수는 원소의개수 X log(원소의개수)의 시간 복잡도를 가짐 qsort임.
	//또는 [](int a, int b) {return a < b; } (람다([]) 함수를 쓰는게 효율이 제일 좋음)
	
	for (int n : arr)
		cout << n << " ";
	cout << endl;
	save("소스.cpp");
	return 0;
}
===============================================
저장시간 : 2021-03-09 오후 2:01:38 화요일
===============================================
//--------------------------------------------------------------------
// X86 mode & Release mode 에서 프로그램
//
// 2021. 1학기 STL 화56 목56  - 3월 9일 화요일	(2주 1차시)
//
// 많은 수의 데이터 다루기 - int 에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다
//
// sort 설명 다시 - 함수의 역할 / 비교 횟수 등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기


// [문제] int 1,000,000 개를 저장할 공간을 마련하라
// 임의의 값(랜덤엔진과 분포)으로 채워라
// 값을 오름차순으로 정렬하라
// 처음과 마지막 원소만 출력하라.

default_random_engine dre; // 랜덤 엔진
int arr[1000000]; // 지역 변수 스택 할당값은 1mb - 따라서 전역변수에
int main()
{
	uniform_int_distribution uid; // 범위 지정 가능
	for (int& n : arr)
		n = uid(dre);

	sort(begin(arr), end(arr));
	cout << "처음 원소의 값 - " << *begin(arr) << endl;
	cout << "마지막 원소의 값 - " << *(end(arr) - 1) << endl;
	cout << endl;

	save("소스.cpp");
}
------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <string>
#include <string_view>
#include "save.h"
using namespace std;
 
// [문제] 파일 "오름차순 정렬한 int 100개.txt"가 있다.
// 읽어서 화면에 출력


int main()
{
	string_view sv = "오름차순정렬한 int 100개.txt"sv;
	ifstream in(sv.data());
	if (!in) {
		cout << sv << "파일을 열수 없습니다." << endl;
		exit(0);
	}
	int arr[100];
	for (int& n:arr)
		in >> n;

	for (int n : arr)
		cout << n << " ";
	cout << endl;
	save("소스.cpp");
}
------------------------------------------------------------------------------------------
#include <iostream>
#include <fstream>
#include <numeric>
#include "save.h"
using namespace std;
 
// [문제] 정수 100개를 400바이트 공간에 기록하자.
// int a[100]개 값을 1부터 100으로 채우고
// 파일 "int 100개.txt"에 저장
// 파일 크기는 무조건 400byte
int main()
{
	int arr[100];
	iota(begin(arr), end(arr), 1);
	ofstream out("int 100개.txt");
	
	out.write((char*)arr, 100 * sizeof(int));

	save("소스.cpp");
}

===============================================
저장시간 : 2021-03-11 오후 1:45:59 목요일
===============================================
//--------------------------------------------------------------------
// X86 mode & Release mode 에서 프로그램
//
// 2021. 1학기 STL 화56 목56  - 3월 11일 목요일	(2주 2차시)
//
// 많은 수의 데이터 다루기 - int 에서 시작
// 갯수를 늘리며 자료가 저장되는 방식과 공간을 이해한다.
// 많은 수의 자료를 저장하는 방식을 알아본다
//
// sort 설명 다시 - 함수의 역할 / 비교 횟수 등을 살펴보자
// 객체를 많이 만들어 반복
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//--------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"
using namespace std;
 
// [문제] 파일 "int 100개.txt"에 바이너리로 저장되어있는 정수 100개가 있다.
// 읽은 정수 100개를 내림차순으로 정렬한 후 출력.

int main()
{
	int arr[100];
	ifstream in("int 100개.txt", ios::binary);

	if (!in)
		exit(0);

	in.read((char*)&arr, 100 * sizeof(int));
	sort(begin(arr), end(arr), [](int a, int b) {return a > b; });

	for (int n : arr)
		cout << n << " ";
	
	cout << endl;
	
	save("소스.cpp");

}
------------------------------------------------------------------------------------------
#include <iostream>
#include <numeric>
#include "save.h"
using namespace std;
 
// [문제] 사용자가 원하는 갯수 num만큼 int를 저장할 공간을 확보한다
// 이 공간을 1부터 num까지 숫자로 채워라.
// 처음과 마지막 값을 화면에 출력.
int main()
{
	cout << "몇개의 int를 원하십니까: ";
	int num;
	cin >> num;
	int* arr;
		try {
		arr = new int[num]; // 배열 버전 new 연산자를 사용한다. *배열 길이는 상수가 아니여도 된다*. 
	}
	catch (exception& e) {
		cout << e.what() << endl;
	} // 예외가 발생했을경우 프로그램 강제종료가 아닌 오류 메세지 출력 
	for (int i = 0; i < num; i++)
		arr[i] = i + 1;
	cout << "처음 원소의 값: " << arr[0] << endl;
	cout << "마지막 원소의 값: " << arr[num - 1] << endl;

	delete[] arr;
	save("소스.cpp");
}
------------------------------------------------------------------------------------------
#include <iostream>
#include "save.h"
using namespace std;

// core c++ guide - raw pointer를 사용하지 말 것.

int main()
{
	int cnt{};
	while (true) {
		// 확보한 자원은 지역을 벗어나며 자동으로 메모리 해제(delete)
		unique_ptr<char[]> p{ new char[500000000] };

		cout << ++cnt << "\r";
		break;

	}
	save("소스.cpp");
}===============================================
저장시간 : 2021-03-11 오후 3:18:16 목요일
===============================================
//--------------------------------------------------------------------
// 2021. 1학기 STL 화56 목56  - 3월 11일 목요일	(2주 2차시)
//
// 알고리즘 시간재기
// 스마트 포인터
//
// 앞으로 사용할 관찰용 class 만들어 두기
//--------------------------------------------------------------------

#include <iostream>
#include <thread>
#include <chrono>
#include "save.h"
using namespace std;

int main()
{
	//(수까락의 프로그래밍 참고)
	auto b = chrono::steady_clock::now();	//스톱워치 시작
	this_thread::sleep_for(100ms);
	auto e = chrono::steady_clock::now();	// 스톱워치 끝
	auto d = e - b;
	cout << "경과시간(밀리초) - " << chrono::duration_cast<chrono::milliseconds>(d).count() << endl;
	save("소스.cpp");
}